\documentclass[aip,preprint]{revtex4-1}

\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{braket}
\usepackage{xspace}

\usepackage[capitalize]{cleveref}

\begin{document}

\title{Technical Notes: Fock Matrix Builder}

\author{Francesco A. Evangelista}
\email{francesco.evangelista@emory.edu}
\affiliation{Department of Chemistry and Cherry Emerson Center for Scientific Computation, Emory University, Atlanta, GA 30322, USA}

\date{\today}


\maketitle

\section{Introduction}
In this note, we consider ways to implement the 
Coulomb matrix:
\begin{equation}
J_{\mu \nu} = \sum_{\rho \sigma} (\mu \nu | \rho \sigma) D_{\rho \sigma},
\end{equation}
and the exchange matrix:
\begin{equation}
K_{\mu \nu} = \sum_{\rho \sigma} (\mu \rho | \nu \sigma) D_{\rho \sigma},
\end{equation}
where we take the density matrix to be defined as
\begin{equation}
D_{\rho \sigma} = \sum_i^{\mathrm{occ}} n_i C_{\rho i} C_{\sigma i}.
\end{equation}

Let's consider an auxiliary basis and the corresponding approximation to the four-center Coulomb integrals
\begin{equation}
\begin{split}
(\mu \nu | \rho \sigma) & = \sum_{PQ} (\mu \nu | P) (P|Q)^{-1} (Q|\rho \sigma) \\
& = \sum_{PQR} (\mu \nu | P) (P|Q)^{-1/2} (Q|R)^{-1/2} (R|\rho \sigma) \\
& = \sum_{P} B^{P}_{\mu \nu} B^{P}_{\rho \sigma},
\end{split}
\end{equation}
where we have defined
\begin{equation}
B^{P}_{\mu \nu} = \sum_Q (P|Q)^{-1/2} (Q|\mu \nu).
\end{equation}

\section{Coulomb matrix algorithm}

The Coulomb matrix can be computed efficiently as
\begin{equation}
\begin{split}
J_{\mu \nu} = \sum_{P} B^{P}_{\mu \nu}
\underbrace{\left( \sum_{\rho \sigma}B^{P}_{\rho \sigma} D_{\rho \sigma} \right)}_{B^P}=
\sum_{P} B^{P}_{\mu \nu} B^P.
\end{split}
\end{equation}
If we cannot store the B tensors, then we can do the following:
\begin{equation}
\begin{split}
J_{\mu \nu} & = \sum_{PQ} (\mu \nu | P) (P|Q)^{-1}
\underbrace{\sum_{\rho \sigma} (Q|\rho \sigma) D_{\rho \sigma}}_{a_Q} \\
 & = \sum_{P} (\mu \nu | P) \underbrace{\sum_{Q} (P|Q)^{-1} a_Q}_{b_P} \\
 & = \sum_{P} (\mu \nu | P) b_P
\end{split}
\end{equation}

The Coulomb operator can be implemented in the following way.
\begin{enumerate}
    \item Compute the vector of size $N_\mathrm{aux}$ on the fly without storage:
\begin{equation}
a_Q = \sum_{\rho \geq \sigma} (Q|\rho \sigma) D_{\rho \sigma} (1+\delta_{\rho \sigma})
\end{equation}
In this step, one can apply screening based on $D_{\rho \sigma}$ and $(Q|\rho \sigma)$. 

    \item Matrix vector multiplication
\begin{equation}
b_P = \sum_{Q} (P|Q)^{-1} a_Q
\end{equation}
    \item Second pass over all the three-center integrals
\begin{equation}
J_{\mu \nu} = \sum_{P} (\mu \nu | P) b_P, \quad \text{ for } \mu \geq \nu.
\end{equation}
In this step, one can apply integral screening of $(\mu \nu | P)$ to reduce the evaluation cost.
\end{enumerate}

\section{Exchange matrix algorithm}

The exchange matrix can be computed efficiently as
\begin{equation}
\begin{split}
K_{\mu \nu} &= \sum_{P} \sum_{i}
\sum_{\rho \sigma} B^{P}_{\mu \rho} B^{P}_{\nu \sigma} C_{\rho i} C_{\sigma i} n_i \\
&= \sum_{P} \sum_{i}
\left(\sum_{\rho} B^{P}_{\mu \rho}  C_{\rho i}\sqrt{n_i} \right)
\underbrace{\left(\sum_{\sigma} B^{P}_{\nu \sigma} C_{\sigma i} \sqrt{n_i}\right)}_{Y_{P \nu i}} \\
&= \sum_{P} \sum_{i}
Y_{P \mu i} Y_{P \nu i}
\end{split}
\end{equation}
With the most expensive step being the evaluation of $Y_{P \mu i}$ which scales as $N_\mathrm{aux} N^2 O$ and requires additional storage of $N_\mathrm{aux} N O$.

\begin{equation}
\begin{split}
Y_{P \mu i} & = \sum_{\rho} B^{P}_{\mu \rho} C_{\rho i}\sqrt{n_i} \\
& = \sum_{\rho} \sum_{Q} (P|Q)^{-1/2} (Q | \mu \rho) C_{\rho i}\sqrt{n_i} \\
& = \sum_{Q} (P|Q)^{-1/2} \sum_{\rho} (Q | \mu \rho) C_{\rho i}\sqrt{n_i} \\
& = \sum_{Q} (P|Q)^{-1/2} X_{Q \mu i},
\end{split}
\end{equation}
where
\begin{equation}
X_{Q \mu i} = \sum_{\rho} (Q | \mu \rho) C_{\rho i}\sqrt{n_i}
\end{equation}

The exchange operator can be implemented in the following way.
\begin{enumerate}
    \item Compute the tensor $X_{Q \mu i}$ with storage cost of $N_\mathrm{aux} N O$ by doing one on-the-fly pass over the three-center integrals, evaluating only the part $\mu \geq \rho$ and using the fact that $(Q | \mu \rho)=(Q | \rho \mu)$:
\begin{equation}
X_{Q \mu i} = \sum_{\rho} (Q | \mu \rho) C_{\rho i} \sqrt{n_i}
\end{equation}
Here if the orbital is localized, then one can apply screening based on only those shells on which $C_{\rho i}$ has support and this can be combined with integral screening of $(Q | \mu \rho)$.

    \item Compute the matrix-tensor product which yields an intermediate of the same dimension ($N_\mathrm{aux} N O$):
\begin{equation}
Y_{P \mu i} = \sum_{Q} (P|Q)^{-1/2} X_{Q \mu i},
\end{equation}
    \item Contract the two tensors:
\begin{equation}
K_{\mu \nu} = \sum_{P} \sum_{i} Y_{P \mu i} Y_{P \nu i}
\end{equation}
\end{enumerate}
If we cannot store the full $X_{Q \mu i}$ then we can do the following. Split the sum over $i$ into
\begin{equation}
\sum_i = \sum_{\alpha=1}^{r} \sum_{i \in [i]_\alpha}
\end{equation}
where $[i]_\alpha$ indicates a range of indices $[i]_\alpha = \{n_{\alpha-1}, n_{\alpha-1} + 1, n_{\alpha-1} + 2, \ldots, n_{\alpha} - 1\}$ where $n_{\alpha-1}$ and $n_{\alpha}$ are the start and end (excluded) of the range.
Then we can split the ranges evenly and determine the maximum size of the slice of the tensor $X_{Q\mu [i]_\alpha}$ that fits in memory:
\begin{equation}
r = \frac{N_\mathrm{aux} N O}{\textrm{memory}}
\end{equation}

Then the algorithm is implemented by performing $r$ passes over the three-center integrals and storing
\begin{equation}
X_{Q \mu [i]_\alpha} = \sum_{\rho} (Q | \mu \rho) C_{\rho [i]_\alpha}\sqrt{n_{[i]_\alpha}}
\end{equation}
which is then transformed to $Y$ and accumulated into the exchange matrix.
Since we need to do two passes for the Coulomb matrix, we can go ahead and use these two passes to compute both $J$ and $K$ at the same time reducing the storage cost of the exchange algorithm to $N_\mathrm{aux} N O/2$.

\end{document}

